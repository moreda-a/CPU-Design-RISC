-- Copyright (C) 1991-2015 Altera Corporation. All rights reserved.
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic 
-- functions, and any output files from any of the foregoing 
-- (including device programming or simulation files), and any 
-- associated documentation or information are expressly subject 
-- to the terms and conditions of the Altera Program License 
-- Subscription Agreement, the Altera Quartus Prime License Agreement,
-- the Altera MegaCore Function License Agreement, or other 
-- applicable license agreement, including, without limitation, 
-- that your use is for the sole purpose of programming logic 
-- devices manufactured by Altera and sold by Altera or its 
-- authorized distributors.  Please refer to the applicable 
-- agreement for further details.

-- Generated by Quartus Prime Version 15.1.1 Build 189 12/02/2015 SJ Lite Edition
-- Created on Tue Nov 15 20:24:42 2016

LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY ControlLogicGates IS
    PORT (
        reset : IN STD_LOGIC := '0';
        clock : IN STD_LOGIC;
        r : IN STD_LOGIC := '0';
        si : IN STD_LOGIC := '0';
        ze : IN STD_LOGIC := '0';
        eq : IN STD_LOGIC := '0';
        ov : IN STD_LOGIC := '0';
        ready : IN STD_LOGIC := '0';
        opi : IN STD_LOGIC_VECTOR(4 DOWNTO 0) := "00000";
        ir : IN STD_LOGIC_VECTOR(31 DOWNTO 0) := "00000000000000000000000000000000";
        tr_load : OUT STD_LOGIC;
        tr_wdb : OUT STD_LOGIC;
        op : OUT STD_LOGIC_VECTOR(2 DOWNTO 0);
        reg_wdb : OUT STD_LOGIC;
        reg_we : OUT STD_LOGIC;
        reg_ra : OUT STD_LOGIC_VECTOR(4 DOWNTO 0);
        ac_wdb : OUT STD_LOGIC;
        ac_lmul : OUT STD_LOGIC;
        ac_lreg : OUT STD_LOGIC;
        ac_load : OUT STD_LOGIC;
        ir_wab : OUT STD_LOGIC;
        ir_wdb : OUT STD_LOGIC;
        ir_ldb : OUT STD_LOGIC;
        ir_load : OUT STD_LOGIC;
        dr_lmul : OUT STD_LOGIC;
        dr_load : OUT STD_LOGIC;
        sp_wab : OUT STD_LOGIC;
        sp_dec : OUT STD_LOGIC;
        sp_inc : OUT STD_LOGIC;
        sp_set : OUT STD_LOGIC;
        pc_wab : OUT STD_LOGIC;
        pc_wdb : OUT STD_LOGIC;
        pc_lad : OUT STD_LOGIC;
        pc_clear : OUT STD_LOGIC;
        pc_inc : OUT STD_LOGIC;
        pc_load : OUT STD_LOGIC;
        pc_set : OUT STD_LOGIC;
        ar_load : OUT STD_LOGIC;
        mem_wab : OUT STD_LOGIC;
        mem_wdb : OUT STD_LOGIC;
        start : OUT STD_LOGIC;
        rwn : OUT STD_LOGIC
    );
END ControlLogicGates;

ARCHITECTURE BEHAVIOR OF ControlLogicGates IS
    TYPE type_fstate IS (state1,state2,state4,state5,state7,state6,state3,state8,state9,state10);
    SIGNAL fstate : type_fstate;
    SIGNAL reg_fstate : type_fstate;
BEGIN
    PROCESS (clock,reg_fstate)
    BEGIN
        IF (clock='1' AND clock'event) THEN
            fstate <= reg_fstate;
        END IF;
    END PROCESS;

    PROCESS (fstate,reset,r,si,ze,eq,ov,ready,opi,ir)
    BEGIN
        IF (reset='1') THEN
            reg_fstate <= state1;
            tr_load <= '0';
            tr_wdb <= '0';
            op <= "000";
            reg_wdb <= '0';
            reg_we <= '0';
            reg_ra <= "00000";
            ac_wdb <= '0';
            ac_lmul <= '0';
            ac_lreg <= '0';
            ac_load <= '0';
            ir_wab <= '0';
            ir_wdb <= '0';
            ir_ldb <= '0';
            ir_load <= '0';
            dr_lmul <= '0';
            dr_load <= '0';
            sp_wab <= '0';
            sp_dec <= '0';
            sp_inc <= '0';
            sp_set <= '0';
            pc_wab <= '0';
            pc_wdb <= '0';
            pc_lad <= '0';
            pc_clear <= '0';
            pc_inc <= '0';
            pc_load <= '0';
            pc_set <= '0';
            ar_load <= '0';
            mem_wab <= '0';
            mem_wdb <= '0';
            start <= '0';
            rwn <= '0';
        ELSE
            tr_load <= '0';
            tr_wdb <= '0';
            op <= "000";
            reg_wdb <= '0';
            reg_we <= '0';
            reg_ra <= "00000";
            ac_wdb <= '0';
            ac_lmul <= '0';
            ac_lreg <= '0';
            ac_load <= '0';
            ir_wab <= '0';
            ir_wdb <= '0';
            ir_ldb <= '0';
            ir_load <= '0';
            dr_lmul <= '0';
            dr_load <= '0';
            sp_wab <= '0';
            sp_dec <= '0';
            sp_inc <= '0';
            sp_set <= '0';
            pc_wab <= '0';
            pc_wdb <= '0';
            pc_lad <= '0';
            pc_clear <= '0';
            pc_inc <= '0';
            pc_load <= '0';
            pc_set <= '0';
            ar_load <= '0';
            mem_wab <= '0';
            mem_wdb <= '0';
            start <= '0';
            rwn <= '0';
            CASE fstate IS
                WHEN state1 =>
                    reg_fstate <= state2;

                    pc_load <= '1';

                    sp_set <= '1';
                WHEN state2 =>
                    IF ((ready = '1')) THEN
                        reg_fstate <= state3;
                    -- Inserting 'else' block to prevent latch inference
                    ELSE
                        reg_fstate <= state2;
                    END IF;

                    mem_wdb <= '1';

                    pc_clear <= '1';

                    pc_set <= '1';

                    pc_wab <= '1';
                WHEN state4 =>
                    IF (((((((((opi(4 DOWNTO 0) = "11100") AND (r = '1')) AND (si = '1')) AND (ze = '1')) AND (eq = '1')) AND (ov = '1')) AND (ready = '1')) AND (ir(3) = '1'))) THEN
                        reg_fstate <= state10;
                    ELSIF ((opi(4 DOWNTO 0) = "00001")) THEN
                        reg_fstate <= state5;
                    ELSIF (((opi(4 DOWNTO 0) = "10011") AND (ready = '1'))) THEN
                        reg_fstate <= state8;
                    ELSIF ((opi(4 DOWNTO 0) = "10100")) THEN
                        reg_fstate <= state9;
                    -- Inserting 'else' block to prevent latch inference
                    ELSE
                        reg_fstate <= state4;
                    END IF;

                    mem_wdb <= '1';

                    mem_wab <= '1';

                    pc_set <= '1';

                    ir_ldb <= '1';

                    ir_load <= '1';
                WHEN state5 =>
                    reg_fstate <= state6;

                    ac_lreg <= '1';

                    reg_ra <= ir(21 DOWNTO 17);

                    ac_load <= '1';
                WHEN state7 =>
                    reg_fstate <= state2;

                    reg_wdb <= '1';

                    ac_wdb <= '1';

                    reg_we <= '1';
                WHEN state6 =>
                    reg_fstate <= state7;

                    ac_lmul <= '1';

                    ac_load <= '1';

                    tr_load <= '1';

                    op <= "001";
                WHEN state3 =>
                    IF ((ready = '1')) THEN
                        reg_fstate <= state4;
                    -- Inserting 'else' block to prevent latch inference
                    ELSE
                        reg_fstate <= state3;
                    END IF;

                    mem_wdb <= '1';

                    mem_wab <= '1';

                    pc_clear <= '1';

                    pc_set <= '1';

                    pc_wab <= '1';

                    ir_load <= '1';
                WHEN state8 =>
                    reg_fstate <= state2;

                    mem_wab <= '1';

                    reg_wdb <= '1';

                    reg_we <= '1';
                WHEN state9 =>
                    IF ((ready = '1')) THEN
                        reg_fstate <= state2;
                    -- Inserting 'else' block to prevent latch inference
                    ELSE
                        reg_fstate <= state9;
                    END IF;

                    start <= '1';

                    reg_wdb <= '1';
                WHEN state10 =>
                    reg_fstate <= state10;

                    pc_lad <= '1';

                    pc_load <= '1';

                    mem_wdb <= '1';

                    mem_wab <= '1';

                    pc_clear <= '1';

                    pc_inc <= '1';

                    pc_wdb <= '1';

                    ar_load <= '1';

                    start <= '1';

                    pc_set <= '1';

                    rwn <= '1';

                    sp_set <= '1';

                    pc_wab <= '1';

                    reg_wdb <= '1';

                    dr_load <= '1';

                    sp_wab <= '1';

                    ac_lreg <= '1';

                    ac_lmul <= '1';

                    ac_wdb <= '1';

                    reg_ra <= "00001";

                    dr_lmul <= '1';

                    sp_dec <= '1';

                    sp_inc <= '1';

                    ir_wab <= '1';

                    ac_load <= '1';

                    reg_we <= '1';

                    tr_load <= '1';

                    ir_wdb <= '1';

                    ir_ldb <= '1';

                    ir_load <= '1';

                    op <= "001";

                    tr_wdb <= '1';
                WHEN OTHERS => 
                    tr_load <= 'X';
                    tr_wdb <= 'X';
                    op <= "XXX";
                    reg_wdb <= 'X';
                    reg_we <= 'X';
                    reg_ra <= "XXXXX";
                    ac_wdb <= 'X';
                    ac_lmul <= 'X';
                    ac_lreg <= 'X';
                    ac_load <= 'X';
                    ir_wab <= 'X';
                    ir_wdb <= 'X';
                    ir_ldb <= 'X';
                    ir_load <= 'X';
                    dr_lmul <= 'X';
                    dr_load <= 'X';
                    sp_wab <= 'X';
                    sp_dec <= 'X';
                    sp_inc <= 'X';
                    sp_set <= 'X';
                    pc_wab <= 'X';
                    pc_wdb <= 'X';
                    pc_lad <= 'X';
                    pc_clear <= 'X';
                    pc_inc <= 'X';
                    pc_load <= 'X';
                    pc_set <= 'X';
                    ar_load <= 'X';
                    mem_wab <= 'X';
                    mem_wdb <= 'X';
                    start <= 'X';
                    rwn <= 'X';
                    report "Reach undefined state";
            END CASE;
        END IF;
    END PROCESS;
END BEHAVIOR;
